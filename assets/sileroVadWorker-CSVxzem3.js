const V=(t,n,e)=>Math.max(n,Math.min(e,t)),X=(t,n,e)=>Math.round(t*n/e),W=(t,n)=>{if(n===16e3)return t.slice();if(t.length===0)return new Float32Array;const e=n/16e3,o=Math.max(1,Math.floor(t.length/e)),s=new Float32Array(o);for(let a=0;a<o;a++){const i=a*e,r=Math.floor(i),A=i-r,c=Math.min(r+1,t.length-1);s[a]=t[r]*(1-A)+t[c]*A}return s},$=(t,n)=>{if(!t.length)return 0;const e=Array.from(t).sort((s,a)=>s-a),o=Math.max(0,Math.min(e.length-1,Math.floor(n*(e.length-1))));return e[o]};let H=null,j="";const G=t=>t?t.endsWith("/")?t:`${t}/`:"/",P=(t,n)=>{const e=t.map(o=>o.toLowerCase());for(const o of n){const s=e.indexOf(o);if(s>=0)return t[s]}for(const o of n){const s=e.findIndex(a=>a.includes(o));if(s>=0)return t[s]}},K=(t,n)=>{const e=(t==null?void 0:t.dimensions)??[];return e.length>=2&&e.every(s=>typeof s=="number"&&s>0)?e:n},J=t=>{const n=(t==null?void 0:t.dimensions)??[];return n.length===3?[1,1,512]:n.length===2?[1,512]:[1,512]},Y=async t=>{const n=G(t);return(!H||j!==n)&&(j=n,H=(async()=>{var L,R,w,g;const e=await import("./ort.wasm.bundle.min-BaZw1o6s.js"),o=new URL("onnxruntime/",n).toString();e.env.wasm.wasmPaths=o,e.env.wasm.numThreads=1;const s=new URL("models/silero_vad.onnx",n).toString(),a=await e.InferenceSession.create(s,{executionProviders:["wasm"],graphOptimizationLevel:"all"}),i=a.inputNames,r=a.outputNames,A=P(i,["input"])??i[0],c=P(i,["state"]),M=P(i,["h"]),_=P(i,["c"]),p=P(i,["sr","sample_rate"])??i.find(S=>S!==A&&S!==c&&S!==M&&S!==_)??i[1],h=!!c&&!M&&!_,T=P(r,["output"])??r[0],I=h?P(r,["staten","state_n","state"])??r.find(S=>S!==T):void 0,O=h?void 0:P(r,["hn","h"])??r[1],N=h?void 0:P(r,["cn","c"])??r[2],E=J((L=a.inputMetadata)==null?void 0:L[A]),m=h?K((R=a.inputMetadata)==null?void 0:R[c??""],[2,1,128]):void 0,d=h?void 0:K((w=a.inputMetadata)==null?void 0:w[M??""],[2,1,64]),l=h?void 0:K((g=a.inputMetadata)==null?void 0:g[_??""],[2,1,64]);return{ort:e,session:a,inputName:A,srName:p,outputName:T,inputShape:E,useState:h,stateName:c,stateOutputName:I,stateShape:m,hName:M,cName:_,hnName:O,cnName:N,hShape:d,cShape:l}})()),H},Z=async(t,n)=>{var w,g,S;const e=await Y(n),{ort:o,session:s,inputName:a,srName:i,outputName:r,inputShape:A,useState:c,stateName:M,stateOutputName:_,stateShape:p,hName:h,cName:T,hnName:I,cnName:O,hShape:N,cShape:E}=e;if(t.length===0)return new Float32Array;if(c){if(!M||!p||!_)throw new Error("Silero VADモデルの状態入出力が見つかりません。")}else if(!h||!T||!N||!E||!I||!O)throw new Error("Silero VADモデルの入出力が見つかりません。");let m=null,d=null,l=null;c&&p?m=new Float32Array(p.reduce((u,f)=>u*f,1)):!c&&N&&E&&(d=new Float32Array(N.reduce((u,f)=>u*f,1)),l=new Float32Array(E.reduce((u,f)=>u*f,1)));const L=new o.Tensor("int64",new BigInt64Array([BigInt(16e3)]),[1]),R=[];for(let u=0;u<t.length;u+=320){const f=new Float32Array(512),y=t.subarray(u,Math.min(u+512,t.length));f.set(y);const D={[a]:new o.Tensor("float32",f,A),[i]:L};c&&M&&p&&m?D[M]=new o.Tensor("float32",m,p):!c&&h&&T&&N&&E&&d&&l&&(D[h]=new o.Tensor("float32",d,N),D[T]=new o.Tensor("float32",l,E));const v=await s.run(D),B=v[r].data,U=typeof B[0]=="number"?B[0]:Number(B[0]);if(R.push(U??0),c&&_){const x=(w=v[_])==null?void 0:w.data;x&&(m=new Float32Array(x))}else if(!c&&I&&O){const x=(g=v[I])==null?void 0:g.data,F=(S=v[O])==null?void 0:S.data;x&&F&&(d=new Float32Array(x),l=new Float32Array(F))}}return Float32Array.from(R)},tt=async t=>{const{samples:n,sampleRate:e,fps:o,tuning:s,baseUrl:a}=t;if(n.length===0||e<=0||o<=0)return[];const i=W(n,e),r=await Z(i,a),A=V(s.probabilityBase??.5,.05,.95),c=V(s.thresholdScale??1,.5,1.5),M=$(r,.2),_=Math.max(A,M*2),p=V(_*c,.05,.95),h=V(s.probabilityHysteresis??.7,.4,.95),T=V(p*h,.05,p),I=V(s.speechRatio??.5,.1,.95),O=Math.max(1,Math.round(s.holdFrames??2)),N=Math.floor(n.length*o/e),E=[];let m=!1,d=0;for(let l=0;l<N;l++){const L=X(l,e,o),R=X(l+1,e,o),w=Math.min(R,n.length);if(L>=w)break;let g=0;for(let y=L;y<w;y++)g+=n[y]*n[y];const S=w-L,u=S>0?Math.sqrt(g/S):0;let f=!1;if(r.length>0){const y=l/o,D=(l+1)/o,v=Math.max(0,Math.floor(y*16e3)),k=Math.max(v+1,Math.floor(D*16e3)),B=Math.floor(v/320),U=Math.floor((k-1)/320),x=r.length-1,F=Math.max(0,Math.min(x,B)),b=Math.max(0,Math.min(x,U));if(b>=F){const Q=m?T:p;let q=0;const z=b-F+1;for(let C=F;C<=b;C++)r[C]>=Q&&q++;f=(z>0?q/z:0)>=I}}else f=u>=(s.startThreshold??.05);m?f?d=0:(d+=1,d>=O&&(m=!1,d=0)):f&&(m=!0,d=0),E.push({frameIndex:l,time:l/o,volume:u,isSpeech:m})}return E};self.onmessage=t=>{const n=t.data;n&&(async()=>{try{const e=await tt(n),o={id:n.id,frames:e};self.postMessage(o)}catch(e){const o=e instanceof Error?e.message:String(e),s={id:n.id,error:o};self.postMessage(s)}})()};
