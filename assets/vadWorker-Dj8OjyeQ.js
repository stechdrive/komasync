const f=Math.round(320),R=(o,t,e)=>Math.max(t,Math.min(e,o)),C=(o,t,e)=>Math.round(o*t/e),H=(o,t)=>{if(t===16e3)return o.slice();if(o.length===0)return new Float32Array;const e=t/16e3,n=Math.max(1,Math.floor(o.length/e)),a=new Float32Array(n);for(let r=0;r<n;r++){const p=r*e,u=Math.floor(p),M=p-u,c=Math.min(u+1,o.length-1);a[r]=o[u]*(1-M)+o[c]*M}return a},B=o=>{const t=new Int16Array(o.length);for(let e=0;e<o.length;e++){const n=R(o[e],-1,1);t[e]=n<0?n*32768:n*32767}return t};let v=null,m=0;const G=async()=>(v||(v=(async()=>{const o=await import("./webrtcvad-pXR_IZDd.js").then(function(e){return e.w}),t=o.default??o.WebRtcVad??o;if(typeof t!="function")throw new Error("WebRtcVadのロードに失敗しました。");return await t()})()),v),J=async o=>{const t=await G();if(!m&&(m=t.Create(),!m))throw new Error("VADインスタンスの作成に失敗しました。");t.Init(m);const e=R(Math.round(o),0,3);return t.set_mode(m,e),{module:t,handle:m}},K=async o=>{const{samples:t,sampleRate:e,fps:n,tuning:a}=o;if(t.length===0||e<=0||n<=0)return[];const{module:r,handle:p}=await J(a.aggressiveness??2),u=H(t,e),M=B(u),c=Math.floor(M.length/f),x=new Array(c).fill(!1);if(c>0){let s=0;try{if(s=r.malloc(f*2),!s)throw new Error("VADバッファの確保に失敗しました。");const i=new Int16Array(r.HEAP16.buffer,s,f);for(let h=0;h<c;h++){const l=h*f;i.set(M.subarray(l,l+f));const g=r.Process(p,16e3,s,f);x[h]=g===1}}finally{s&&r.free(s)}}const q=Math.floor(t.length*n/e),D=[],w=a.startThreshold??.05,j=a.endThreshold??w*.85,k=R(a.speechRatio??.5,.1,.9),W=Math.max(1,Math.round(a.holdFrames??2));let E=!1,A=0;const F=f/16e3;for(let s=0;s<q;s++){const i=C(s,e,n),h=C(s+1,e,n),l=Math.min(h,t.length);if(i>=l)break;let g=0;for(let d=i;d<l;d++)g+=t[d]*t[d];const P=l-i,S=P>0?Math.sqrt(g/P):0;let _=!1;if(c>0){const d=i/e,z=l/e,I=c-1,y=Math.max(0,Math.min(I,Math.floor(d/F))),T=Math.max(0,Math.min(I,Math.floor((z-1e-6)/F)));if(T>=y){let L=0;const b=T-y+1;for(let V=y;V<=T;V++)x[V]&&L++;_=(b>0?L/b:0)>=k}}else _=S>=w;E?_||S>=j?A=0:(A+=1,A>=W&&(E=!1,A=0)):_&&S>=w&&(E=!0,A=0),D.push({frameIndex:s,time:s/n,volume:S,isSpeech:E})}return D};self.onmessage=o=>{const t=o.data;t&&(async()=>{try{const e=await K(t),n={id:t.id,frames:e};self.postMessage(n)}catch(e){const n=e instanceof Error?e.message:String(e),a={id:t.id,error:n};self.postMessage(a)}})()};
